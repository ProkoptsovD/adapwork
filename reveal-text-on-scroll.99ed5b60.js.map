{"mappings":"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","sources":["src/js/reveal-text-on-scroll.js","node_modules/split-type/dist/index.js","node_modules/@swc/helpers/lib/_class_call_check.js","node_modules/@swc/helpers/lib/_create_class.js","node_modules/@swc/helpers/lib/_object_spread.js","node_modules/@swc/helpers/lib/_define_property.js","node_modules/@swc/helpers/lib/_sliced_to_array.js","node_modules/@swc/helpers/lib/_array_with_holes.js","node_modules/@swc/helpers/lib/_iterable_to_array.js","node_modules/@swc/helpers/lib/_non_iterable_rest.js","node_modules/@swc/helpers/lib/_unsupported_iterable_to_array.js","node_modules/@swc/helpers/lib/_array_like_to_array.js","node_modules/@swc/helpers/lib/_to_consumable_array.js","node_modules/@swc/helpers/lib/_array_without_holes.js","node_modules/@swc/helpers/lib/_non_iterable_spread.js"],"sourcesContent":["import SplitType from 'split-type';\n\nif (!gsap || !SplitType) {\n  return console.error('Gsap or SplitType were not loaded');\n}\n\nconst matchesMobile = window?.matchMedia('(max-width: 1243px)')?.matches;\n\nnew SplitType('.split-text', {\n  types: 'words, chars',\n  tagName: 'span',\n});\n\nconst textRevealTimeline = gsap.timeline();\nconst imagesTimeline = gsap.timeline();\n\n/*\n * triggers animation when #white-bevelled-box element\n * is in viewport on 30% of it's size from bottom\n * this animations pulls container with images from bottom to top\n */\nimagesTimeline.to('.scroll-up', {\n  scrollTrigger: {\n    trigger: '#white-bevelled-box',\n    start: 'top 0%',\n    // start: 'bottom 30%',\n    scrub: 0.2,\n    end: '+=2200',\n  },\n  y: '-300%',\n  ease: 'none', // !IMPORTANT\n});\n\n/*\n * triggers animation when #white-bevelled-box element\n * is in viewport on 30% of it's size from bottom\n * this animations puls makes opacity grow on scroll\n */\nimagesTimeline.to('.scroll-up', {\n  scrollTrigger: {\n    trigger: '#white-bevelled-box',\n    start: 'top 0%',\n    scrub: 2,\n    end: '+=500', // some thin like speed or velocity\n  },\n  ease: 'none', // !IMPORTANT\n  opacity: 1,\n});\n\n/*\n * reveal text animation\n */\ntextRevealTimeline.to('#white-bevelled-box', {\n  scrollTrigger: {\n    trigger: '.is--animated_text',\n    start: matchesMobile ? 'top 30%' : 'top 10%',\n    scrub: 0.3,\n    pin: true,\n    containerAnimation: imagesTimeline,\n  },\n  // scale: 1.3,\n});\n\ntextRevealTimeline.from('.is--animated_text .char', {\n  scrollTrigger: {\n    trigger: '.is--animated_text',\n    start: matchesMobile ? 'top 30%' : 'top 10%',\n    end: '+=2000',\n    scrub: 1,\n    pin: true,\n  },\n  opacity: 0.05,\n  // scale: 1.35,\n  ease: 'back.out(2)',\n  stagger: { amount: 10, from: 'start' },\n});\n\ngsap.to('.certificated-by', {\n  opacity: 1,\n  duration: 0.5,\n  scrollTrigger: {\n    trigger: '.certificated-by',\n    start: '60% bottom',\n    scrub: true,\n    once: true,\n  },\n});\n","/**\n * SplitType\n * https://github.com/lukePeavey/SplitType\n * @version 0.3.3\n * @author Luke Peavey <lwpeavey@gmail.com>\n */\n\n// Polyfill the following DOM methods that are not supported in IE 11.\n\n(() => {\n  function append(...nodes) {\n    const length = nodes.length;\n\n    for (let i = 0; i < length; i++) {\n      const node = nodes[i];\n      if (node.nodeType === 1 || node.nodeType === 11) this.appendChild(node);else this.appendChild(document.createTextNode(String(node)));\n    }\n  }\n\n  function replaceChildren(...nodes) {\n    while (this.lastChild) {\n      this.removeChild(this.lastChild);\n    }\n\n    if (nodes.length) this.append(...nodes);\n  }\n\n  function replaceWith(...nodes) {\n    const parent = this.parentNode;\n    let i = nodes.length;\n    if (!parent) return;\n    if (!i) parent.removeChild(this);\n\n    while (i--) {\n      let node = nodes[i];\n\n      if (typeof node !== 'object') {\n        node = this.ownerDocument.createTextNode(node);\n      } else if (node.parentNode) {\n        node.parentNode.removeChild(node);\n      }\n\n      if (!i) {\n        parent.replaceChild(node, this);\n      } else {\n        parent.insertBefore(this.previousSibling, node);\n      }\n    }\n  }\n\n  if (typeof Element !== 'undefined') {\n    if (!Element.prototype.append) {\n      Element.prototype.append = append;\n      DocumentFragment.prototype.append = append;\n    }\n\n    if (!Element.prototype.replaceChildren) {\n      Element.prototype.replaceChildren = replaceChildren;\n      DocumentFragment.prototype.replaceChildren = replaceChildren;\n    }\n\n    if (!Element.prototype.replaceWith) {\n      Element.prototype.replaceWith = replaceWith;\n      DocumentFragment.prototype.replaceWith = replaceWith;\n    }\n  }\n})();\n\n/**\n * Shallow merges the properties of an object with the target object. Only\n * includes properties that exist on the target object. Non-writable properties\n * on the target object will not be over-written.\n *\n * @param {Object} target\n * @param {Object} object\n */\nfunction extend(target, object) {\n  return Object.getOwnPropertyNames(Object(target)).reduce((extended, key) => {\n    const currentValue = Object.getOwnPropertyDescriptor(Object(target), key);\n    const newValue = Object.getOwnPropertyDescriptor(Object(object), key);\n    return Object.defineProperty(extended, key, newValue || currentValue);\n  }, {});\n}\n\n/**\n * Checks if given value is a string\n *\n * @param {any} value\n * @return {boolean} `true` if `value` is a string, else `false`\n */\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\nfunction isArray(value) {\n  return Array.isArray(value);\n}\n\n/**\n * Parses user supplied settings objects.\n */\n\nfunction parseSettings(settings = {}) {\n  const object = extend(settings); // `split` may be used as an alias for the `types` option\n  // Parse the `types` settings into an array of valid split types.\n  // If `types` is explicitly set to an empty string or array, text will not be\n  // split at all.\n\n  let types;\n\n  if (object.types !== undefined) {\n    types = object.types;\n  } else if (object.split !== undefined) {\n    types = object.split;\n  }\n\n  if (types !== undefined) {\n    object.types = (isString(types) || isArray(types) ? String(types) : '').split(',').map(type => String(type).trim()).filter(type => /((line)|(word)|(char))/i.test(type));\n  } // Support `position: absolute` as an alias for `absolute: true`\n\n\n  if (object.absolute || object.position) {\n    object.absolute = object.absolute || /absolute/.test(settings.position);\n  }\n\n  return object;\n}\n\n/**\n * Takes a list of `types` and returns an object\n *\n * @param {string | string[]} value a comma separated list of split types\n * @return {{lines: boolean, words: boolean, chars: boolean}}\n */\n\nfunction parseTypes(value) {\n  const types = isString(value) || isArray(value) ? String(value) : '';\n  return {\n    none: !types,\n    lines: /line/i.test(types),\n    words: /word/i.test(types),\n    chars: /char/i.test(types)\n  };\n}\n\n/**\n * Returns true if `value` is a non-null object.\n * @param {any} value\n * @return {boolean}\n */\nfunction isObject(value) {\n  return value !== null && typeof value === 'object';\n}\n\n/**\n * Returns true if `input` is one of the following:\n * - `Element`\n * - `Text`\n * - `DocumentFragment`\n */\n\nfunction isNode(input) {\n  return isObject(input) && /^(1|3|11)$/.test(input.nodeType);\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n * Original source: Lodash\n *\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3)\n * // => true\n *\n * _.isLength(Number.MIN_VALUE)\n * // => false\n *\n * _.isLength(Infinity)\n * // => false\n *\n * _.isLength('3')\n * // => false\n */\n\nfunction isLength(value) {\n  return typeof value === 'number' && value > -1 && value % 1 === 0;\n}\n/**\n * Checks if `value` is an array-like object\n * @param {any} value\n * @return {boolean} true if `value` is array-like`, else `false`\n * @example\n * isArrayLike(new Array())\n * // => true\n *\n * isArrayLike(document.querySelectorAll('div'))\n * // => true\n *\n * isArrayLike(document.getElementsByTagName('div'))\n * // => true\n *\n * isArrayLike(() => {})\n * // => false\n *\n * isArrayLike({foo: 'bar'})\n * // => false\n *\n * * isArrayLike(null)\n * // => false\n */\n\n\nfunction isArrayLike(value) {\n  return isObject(value) && isLength(value.length);\n}\n\n/**\n * Coerces `value` to an `Array`.\n *\n * @param {any} value\n * @return {any[]}\n * @example\n * // If `value` is any `Array`, returns original `Array`\n * let arr = [1, 2]\n * toArray(arr)\n * // => arr\n *\n * // If `value` is an `ArrayLike`, its equivalent to `Array.from(value)`\n * let nodeList = document.querySelectorAll('div')\n * toArray(nodeList)\n * // => HTMLElement[] s\n *\n * // If value is falsy, returns empty array\n * toArray(null)\n * // => []\n *\n * // For any other type of value, its equivalent to `Array.of(value)`\n * let element = document.createElement('div')\n * toArray(element)\n * // => [element]\n *\n */\n\nfunction toArray(value) {\n  if (isArray(value)) return value;\n  if (value == null) return [];\n  return isArrayLike(value) ? Array.prototype.slice.call(value) : [value];\n}\n\n/**\n * Processes target elements for the splitType function.\n *\n * @param {any} target Can be one of the following:\n * 1. `string` - A css selector\n * 2. `HTMLElement` - A single element\n * 3. `NodeList` - A nodeList\n * 4. `Element[]` - An array of elements\n * 5. `Array<NodeList|Element[]>` - An nested array of elements\n * @returns {Element[]} A flat array HTML elements\n * @return A flat array of elements or empty array if no elements are found\n */\n\nfunction getTargetElements(target) {\n  let elements = target; // If `target` is a selector string...\n\n  if (isString(target)) {\n    if (/^(#[a-z]\\w+)$/.test(target.trim())) {\n      // If `target` is an ID, use `getElementById`\n      elements = document.getElementById(target.trim().slice(1));\n    } else {\n      // Else use `querySelectorAll`\n      elements = document.querySelectorAll(target);\n    }\n  } // Return a flattened array of elements\n\n\n  return toArray(elements).reduce((result, element) => {\n    return [...result, ...toArray(element).filter(isNode)];\n  }, []);\n}\n\nconst {\n  entries,\n  keys,\n  values\n} = Object;\n\nconst expando = `_splittype`;\nconst cache = {};\nlet uid = 0;\n/**\n * Stores data associated with DOM elements or other objects. This is a\n * simplified version of jQuery's data method.\n *\n * @signature Data(owner)\n * @description Get the data store object for the given owner.\n * @param {Object} owner the object that data will be associated with.\n * @return {Object} the data object for given `owner`. If no data exists\n *     for the given object, creates a new data store and returns it.\n *\n * @signature Data(owner, key)\n * @description Get the value\n * @param {Object} owner\n * @param {string} key\n * @return {any} the value of the provided key. If key does not exist, returns\n *     undefined.\n *\n * @signature Data(owner, key, value)\n * @description Sets the given key/value pair in data store\n * @param {Object} owner\n * @param {string} key\n * @param {any} value\n */\n\nfunction set(owner, key, value) {\n  if (!isObject(owner)) {\n    console.warn('[data.set] owner is not an object');\n    return null;\n  }\n\n  const id = owner[expando] || (owner[expando] = ++uid);\n  const data = cache[id] || (cache[id] = {});\n\n  if (value === undefined) {\n    if (!!key && Object.getPrototypeOf(key) === Object.prototype) {\n      cache[id] = { ...data,\n        ...key\n      };\n    }\n  } else if (key !== undefined) {\n    data[key] = value;\n  }\n\n  return value;\n}\nfunction get(owner, key) {\n  const id = isObject(owner) ? owner[expando] : null;\n  const data = id && cache[id] || {};\n\n  if (key === undefined) {\n    return data;\n  }\n\n  return data[key];\n}\n/**\n * Remove all data associated with the given element\n */\n\nfunction remove(element) {\n  const id = element && element[expando];\n\n  if (id) {\n    delete element[id];\n    delete cache[id];\n  }\n}\n/**\n * Remove all temporary data from the store.\n */\n\nfunction cleanup() {\n  entries(cache).forEach(([id, {\n    isRoot,\n    isSplit\n  }]) => {\n    if (!isRoot || !isSplit) {\n      cache[id] = null;\n      delete cache[id];\n    }\n  });\n}\n\n/**\n * Splits a string into an array of words.\n *\n * @param {string} string\n * @param {string | RegExp} [separator = ' ']\n * @return {string[]} Array of words\n */\nfunction toWords(value, separator = ' ') {\n  const string = value ? String(value) : '';\n  return string.trim().replace(/\\s+/g, ' ').split(separator);\n}\n\n/**\n * Based on lodash#split <https://lodash.com/license>\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters &\n * Editors\n */\nconst rsAstralRange = '\\\\ud800-\\\\udfff';\nconst rsComboMarksRange = '\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23';\nconst rsComboSymbolsRange = '\\\\u20d0-\\\\u20f0';\nconst rsVarRange = '\\\\ufe0e\\\\ufe0f';\n/** Used to compose unicode capture groups. */\n\nconst rsAstral = `[${rsAstralRange}]`;\nconst rsCombo = `[${rsComboMarksRange}${rsComboSymbolsRange}]`;\nconst rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]';\nconst rsModifier = `(?:${rsCombo}|${rsFitz})`;\nconst rsNonAstral = `[^${rsAstralRange}]`;\nconst rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}';\nconst rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]';\nconst rsZWJ = '\\\\u200d';\n/** Used to compose unicode regexes. */\n\nconst reOptMod = `${rsModifier}?`;\nconst rsOptVar = `[${rsVarRange}]?`;\nconst rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';\nconst rsSeq = rsOptVar + reOptMod + rsOptJoin;\nconst rsSymbol = `(?:${[`${rsNonAstral}${rsCombo}?`, rsCombo, rsRegional, rsSurrPair, rsAstral].join('|')}\n)`;\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n\nconst reUnicode = RegExp(`${rsFitz}(?=${rsFitz})|${rsSymbol}${rsSeq}`, 'g');\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n\nconst unicodeRange = [rsZWJ, rsAstralRange, rsComboMarksRange, rsComboSymbolsRange, rsVarRange];\nconst reHasUnicode = RegExp(`[${unicodeRange.join('')}]`);\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\nfunction asciiToArray(string) {\n  return string.split('');\n}\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\n\n\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\n\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\n\nfunction stringToArray(string) {\n  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);\n}\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values.\n *\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\n\nfunction toString(value) {\n  return value == null ? '' : String(value);\n}\n/**\n * Splits `string` into an array of characters. If `separator` is omitted,\n * it behaves likes split.split('').\n *\n * Unlike native string.split(''), it can split strings that contain unicode\n * characters like emojis and symbols.\n *\n * @param {string} [string=''] The string to split.\n * @param {RegExp|string} [separator=''] The separator pattern to split by.\n * @returns {Array} Returns the string segments.\n * @example\n * toChars('foo');\n * // => ['f', 'o', 'o']\n *\n * toChars('foo bar');\n * // => [\"f\", \"o\", \"o\", \" \", \"b\", \"a\", \"r\"]\n *\n * toChars('fðŸ˜€o');\n * // => ['f', 'ðŸ˜€', 'o']\n *\n * toChars('f-ðŸ˜€-o', /-/);\n * // => ['f', 'ðŸ˜€', 'o']\n *\n */\n\n\nfunction toChars(string, separator = '') {\n  string = toString(string);\n\n  if (string && isString(string)) {\n    if (!separator && hasUnicode(string)) {\n      return stringToArray(string);\n    }\n  }\n\n  return string.split(separator);\n}\n\n/**\n * Create an HTML element with the the given attributes\n *\n * attributes can include standard HTML attribute, as well as the following\n * \"special\" properties:\n *   - children: HTMLElement | ArrayLike<HTMLElement>\n *   - textContent: string\n *   - innerHTML: string\n *\n * @param {string} name\n * @param  {Object} [attributes]\n * @returns {HTMLElement}\n */\n\nfunction createElement(name, attributes) {\n  const element = document.createElement(name);\n\n  if (!attributes) {\n    // When called without the second argument, its just return the result\n    // of `document.createElement`\n    return element;\n  }\n\n  Object.keys(attributes).forEach(attribute => {\n    const rawValue = attributes[attribute];\n    const value = isString(rawValue) ? rawValue.trim() : rawValue; // Ignore attribute if the value is `null` or an empty string\n\n    if (value === null || value === '') return;\n\n    if (attribute === 'children') {\n      // Children can be one or more Elements or DOM strings\n      element.append(...toArray(value));\n    } else {\n      // Handle standard HTML attributes\n      element.setAttribute(attribute, value);\n    }\n  });\n  return element;\n}\n\nvar defaults = {\n  splitClass: '',\n  lineClass: 'line',\n  wordClass: 'word',\n  charClass: 'char',\n  types: ['lines', 'words', 'chars'],\n  absolute: false,\n  tagName: 'div'\n};\n\n/**\n * Splits the text content of a single TextNode into words and/or characters.\n *\n * This functions gets called for every text node inside the target element. It\n * replaces the text node with a document fragment containing the split text.\n * Returns an array of the split word and character elements from this node.\n *\n * @param {TextNode} textNode\n * @param {Object} settings\n * @return {{words: Element[], chars: Element[]}}\n */\n\nfunction splitWordsAndChars(textNode, settings) {\n  settings = extend(defaults, settings); // The split types\n\n  const types = parseTypes(settings.types); // the tag name for split text nodes\n\n  const TAG_NAME = settings.tagName; // value of the text node\n\n  const VALUE = textNode.nodeValue; // `splitText` is a wrapper to hold the HTML structure\n\n  const splitText = document.createDocumentFragment(); // Arrays of split word and character elements\n\n  let words = [];\n  let chars = [];\n\n  if (/^\\s/.test(VALUE)) {\n    splitText.append(' ');\n  } // Create an array of wrapped word elements.\n\n\n  words = toWords(VALUE).reduce((result, WORD, idx, arr) => {\n    // Let `wordElement` be the wrapped element for the current word\n    let wordElement;\n    let characterElementsForCurrentWord; // -> If splitting text into characters...\n\n    if (types.chars) {\n      // Iterate through the characters in the current word\n      characterElementsForCurrentWord = toChars(WORD).map(CHAR => {\n        const characterElement = createElement(TAG_NAME, {\n          class: `${settings.splitClass} ${settings.charClass}`,\n          style: 'display: inline-block;',\n          children: CHAR\n        });\n        set(characterElement, 'isChar', true);\n        chars = [...chars, characterElement];\n        return characterElement;\n      });\n    } // END IF;\n\n\n    if (types.words || types.lines) {\n      // -> If Splitting Text Into Words...\n      //    Create an element to wrap the current word. If we are also\n      //    splitting text into characters, the word element will contain the\n      //    wrapped character nodes for this word. If not, it will contain the\n      //    plain text content (WORD)\n      wordElement = createElement(TAG_NAME, {\n        class: `${settings.wordClass} ${settings.splitClass}`,\n        style: `display: inline-block; ${types.words && settings.absolute ? `position: relative;` : ''}`,\n        children: types.chars ? characterElementsForCurrentWord : WORD\n      });\n      set(wordElement, {\n        isWord: true,\n        isWordStart: true,\n        isWordEnd: true\n      });\n      splitText.appendChild(wordElement);\n    } else {\n      // -> If NOT splitting into words OR lines...\n      //    Append the characters elements directly to splitText.\n      characterElementsForCurrentWord.forEach(characterElement => {\n        splitText.appendChild(characterElement);\n      });\n    }\n\n    if (idx < arr.length - 1) {\n      // Add a space after the word.\n      splitText.append(' ');\n    } // If not splitting text into words, we return an empty array\n\n\n    return types.words ? result.concat(wordElement) : result;\n  }, []); // END LOOP;\n  // Add a trailing white space to maintain word spacing\n\n  if (/\\s$/.test(VALUE)) {\n    splitText.append(' ');\n  }\n\n  textNode.replaceWith(splitText);\n  return {\n    words,\n    chars\n  };\n}\n\n/**\n * Splits the text content of a target element into words and/or characters.\n * The function is recursive, it will also split the text content of any child\n * elements into words/characters, while preserving the nested elements.\n *\n * @param {Node} node an HTML Element or Text Node\n * @param {Object} setting splitType settings\n */\n\nfunction split(node, settings) {\n  const type = node.nodeType; // Arrays of split words and characters\n\n  const wordsAndChars = {\n    words: [],\n    chars: []\n  }; // Only proceed if `node` is an `Element`, `Fragment`, or `Text`\n\n  if (!/(1|3|11)/.test(type)) {\n    return wordsAndChars;\n  } // A) IF `node` is TextNode that contains characters other than white space...\n  //    Split the text content of the node into words and/or characters\n  //    return an object containing the split word and character elements\n\n\n  if (type === 3 && /\\S/.test(node.nodeValue)) {\n    return splitWordsAndChars(node, settings);\n  } // B) ELSE `node` is an 'Element'\n  //    Iterate through its child nodes, calling the `split` function\n  //    recursively for each child node.\n\n\n  const childNodes = toArray(node.childNodes);\n\n  if (childNodes.length) {\n    set(node, 'isSplit', true); // we need to set a few styles on nested html elements\n\n    if (!get(node).isRoot) {\n      node.style.display = 'inline-block';\n      node.style.position = 'relative'; // To maintain original spacing around nested elements when we are\n      // splitting text into lines, we need to check if the element should\n      // have a space before and after, and store that value for later.\n      // Note: this was necessary to maintain the correct spacing when nested\n      // elements do not align with word boundaries. For example, a nested\n      // element only wraps part of a word.\n\n      const nextSibling = node.nextSibling;\n      const prevSibling = node.previousSibling;\n      const text = node.textContent || '';\n      const textAfter = nextSibling ? nextSibling.textContent : ' ';\n      const textBefore = prevSibling ? prevSibling.textContent : ' ';\n      set(node, {\n        isWordEnd: /\\s$/.test(text) || /^\\s/.test(textAfter),\n        isWordStart: /^\\s/.test(text) || /\\s$/.test(textBefore)\n      });\n    }\n  } // Iterate through child nodes, calling `split` recursively\n  // Returns an object containing all split words and chars\n\n\n  return childNodes.reduce((result, child) => {\n    const {\n      words,\n      chars\n    } = split(child, settings);\n    return {\n      words: [...result.words, ...words],\n      chars: [...result.chars, ...chars]\n    };\n  }, wordsAndChars);\n}\n\n/**\n * Gets the height and position of an element relative to offset parent.\n * Should be equivalent to offsetTop and offsetHeight, but with sub-pixel\n * precision.\n *\n * TODO needs work\n */\nfunction getPosition(node, isWord, settings, scrollPos) {\n  if (!settings.absolute) {\n    return {\n      top: isWord ? node.offsetTop : null\n    };\n  }\n\n  const parent = node.offsetParent;\n  const [scrollX, scrollY] = scrollPos;\n  let parentX = 0;\n  let parentY = 0;\n\n  if (parent && parent !== document.body) {\n    const parentRect = parent.getBoundingClientRect();\n    parentX = parentRect.x + scrollX;\n    parentY = parentRect.y + scrollY;\n  }\n\n  const {\n    width,\n    height,\n    x,\n    y\n  } = node.getBoundingClientRect();\n  const top = y + scrollY - parentY;\n  const left = x + scrollX - parentX;\n  return {\n    width,\n    height,\n    top,\n    left\n  };\n}\n\n/**\n * Recursively \"un-splits\" text into words.\n * This is used when splitting text into lines but not words.\n * We initially split the text into words so we can maintain the correct line\n * breaks. Once text has been split into lines, we \"un-split\" the words...\n * @param {Element}\n * @return {void}\n */\n\nfunction unSplitWords(element) {\n  if (!get(element).isWord) {\n    toArray(element.children).forEach(child => unSplitWords(child));\n  } else {\n    remove(element);\n    element.replaceWith(...element.childNodes);\n  }\n}\n\nconst createFragment = () => document.createDocumentFragment();\n\nfunction repositionAfterSplit(element, settings, scrollPos) {\n  const types = parseTypes(settings.types);\n  const TAG_NAME = settings.tagName;\n  const nodes = element.getElementsByTagName('*');\n  const wordsInEachLine = [];\n  let wordsInCurrentLine = [];\n  let lineOffsetY = null;\n  let elementHeight;\n  let elementWidth;\n  let contentBox;\n  let lines = [];\n  /**------------------------------------------------\n   ** GET STYLES AND POSITIONS\n   **-----------------------------------------------*/\n  // There is no built-in way to detect natural line breaks in text (when a\n  // block of text wraps to fit its container). To split text into lines, we\n  // have to detect line breaks by checking the top offset of words. This is\n  // why text was split into words first. To apply absolute\n  // positioning, its also necessary to record the size and position of every\n  // split node (lines, words, characters).\n  // To consolidate DOM getting/settings, this is all done at the same time,\n  // before actually splitting text into lines, which involves restructuring\n  // the DOM again.\n  // Cache the element's parent and next sibling (for DOM removal).\n\n  const parent = element.parentElement;\n  const nextSibling = element.nextElementSibling; // a wrapper for the new HTML structure\n\n  const splitText = createFragment(); // get the computed style object for the element\n\n  const cs = window.getComputedStyle(element);\n  const align = cs.textAlign;\n  const fontSize = parseFloat(cs.fontSize);\n  const lineThreshold = fontSize * 0.2; // IF using absolute position...\n\n  if (settings.absolute) {\n    // Let contentBox be an object containing the width and offset position of\n    // the element's content box (the area inside padding box). This is needed\n    // (for absolute positioning) to set the width and position of line\n    // elements, which have not been created yet.\n    contentBox = {\n      left: element.offsetLeft,\n      top: element.offsetTop,\n      width: element.offsetWidth\n    }; // Let elementWidth and elementHeight be the actual width/height of the\n    // element. Also check if the element has inline height or width styles\n    // already set. If it does, cache those values for later.\n\n    elementWidth = element.offsetWidth;\n    elementHeight = element.offsetHeight; // Store the original inline height and width of the element\n\n    set(element, {\n      cssWidth: element.style.width,\n      cssHeight: element.style.height\n    });\n  } // Iterate over every node in the target element\n\n\n  toArray(nodes).forEach(node => {\n    // node is a word element or custom html element\n    const isWordLike = node.parentElement === element; // TODO needs work\n    // Get te size and position of split text nodes\n\n    const {\n      width,\n      height,\n      top,\n      left\n    } = getPosition(node, isWordLike, settings, scrollPos); // If element is a `<br>` tag return here\n\n    if (/^br$/i.test(node.nodeName)) return;\n\n    if (types.lines && isWordLike) {\n      // We compare the top offset of the current word to the top offset of\n      // previous words on the current line. If the difference is greater than\n      // our defined threshold (20%), we assume this word is on a new line.\n      if (lineOffsetY === null || top - lineOffsetY >= lineThreshold) {\n        lineOffsetY = top;\n        wordsInEachLine.push(wordsInCurrentLine = []);\n      } // Add the current word node to the line array\n\n\n      wordsInCurrentLine.push(node);\n    } // END IF\n\n\n    if (settings.absolute) {\n      // Store the size and position split text nodes\n      set(node, {\n        top,\n        left,\n        width,\n        height\n      });\n    }\n  }); // END LOOP\n  // Remove the element from the DOM\n\n  if (parent) {\n    parent.removeChild(element);\n  }\n  /**------------------------------------------------\n   ** SPLIT LINES\n   **-----------------------------------------------*/\n\n\n  if (types.lines) {\n    // Iterate over lines of text (see 11 b)\n    // Let `line` be the array of words in the current line.\n    // Return an array of the wrapped line elements (lineElements)\n    lines = wordsInEachLine.map(wordsInThisLine => {\n      // Create an element to wrap the current line.\n      const lineElement = createElement(TAG_NAME, {\n        class: `${settings.splitClass} ${settings.lineClass}`,\n        style: `display: block; text-align: ${align}; width: 100%;`\n      });\n      set(lineElement, 'isLine', true);\n      const lineDimensions = {\n        height: 0,\n        top: 1e4\n      }; // Append the `lineElement` to `container`\n\n      splitText.appendChild(lineElement); // Iterate over the word-level elements in the current line.\n      // Note: wordOrElement can either be a word node or nested element\n\n      wordsInThisLine.forEach((wordOrElement, idx, arr) => {\n        const {\n          isWordEnd,\n          top,\n          height\n        } = get(wordOrElement);\n        const next = arr[idx + 1]; // Determine line height / y-position\n        // we use the height and offsetTop of the words which we already\n        // recorded. Because custom nested elements could have their own\n        // styles, the words on a line may not all be the same height or\n        // y position. So we take the greatest height / y - offset of the\n        // words on this line.\n\n        lineDimensions.height = Math.max(lineDimensions.height, height);\n        lineDimensions.top = Math.min(lineDimensions.top, top); // append the current word/element\n\n        lineElement.appendChild(wordOrElement); // Determine if there should space after the current element...\n        // If this is not the last word on the current line.\n        // TODO - logic for handing spacing can be improved\n\n        if (isWordEnd && get(next).isWordStart) {\n          lineElement.append(' ');\n        }\n      }); // END LOOP\n\n      if (settings.absolute) {\n        set(lineElement, {\n          height: lineDimensions.height,\n          top: lineDimensions.top\n        });\n      }\n\n      return lineElement;\n    }); // END LOOP\n\n    if (!types.words) {\n      unSplitWords(splitText);\n    } // 10. Insert the new container\n\n\n    element.replaceChildren(splitText);\n  }\n  /**------------------------------------------------\n   **  SET ABSOLUTE POSITION\n   **-----------------------------------------------*/\n  // Apply absolute positioning to all child elements of the target element.\n  // This includes split lines, words, chars, and custom HTML elements that were\n  // included by the user. The size and position of child elements has already\n  // been recorded before splitting text into lines.\n\n\n  if (settings.absolute) {\n    // Set the width/height of the parent element so it does not collapse\n    // when its children are set to absolute position.\n    element.style.width = `${element.style.width || elementWidth}px`;\n    element.style.height = `${elementHeight}px`; // Iterate over all child elements\n\n    toArray(nodes).forEach(node => {\n      const {\n        isLine,\n        top,\n        left,\n        width,\n        height\n      } = get(node);\n      const parentData = get(node.parentElement);\n      const isChildOfLineNode = !isLine && parentData.isLine; // Set the top position of the current node.\n      // -> If `node` a line element, we use the top offset of its first child\n      // -> If `node` the child of line element, then its top offset is zero\n\n      node.style.top = `${isChildOfLineNode ? top - parentData.top : top}px`; // Set the left position of the current node.\n      // -> IF `node` is a line element, this is equal to the position left of\n      //    the content box of the parent element\n      // -> IF `node` is the child of a line element, the value has to adjusted\n      //    so its relative to the line element\n\n      node.style.left = isLine ? `${contentBox.left}px` : `${left - (isChildOfLineNode ? contentBox.left : 0)}px`; // Set the height of the current node to the cached value.\n\n      node.style.height = `${height}px`; //  Set the width of the current node.\n      //  If its a line element, width is equal to the width of the contentBox.\n\n      node.style.width = isLine ? `${contentBox.width}px` : `${width}px`; // Finally, set the node's position to absolute.\n\n      node.style.position = 'absolute';\n    });\n  } // end if;\n  // 14. Re-attach the element to the DOM\n\n\n  if (parent) {\n    if (nextSibling) parent.insertBefore(element, nextSibling);else parent.appendChild(element);\n  }\n\n  return lines;\n}\n\nlet _defaults = extend(defaults, {});\n\nclass SplitType {\n  /**\n   * The internal data store\n   */\n  static get data() {\n    return cache;\n  }\n  /**\n   * The default settings for all splitType instances\n   * @static\n   */\n\n\n  static get defaults() {\n    return _defaults;\n  }\n  /**\n   * Sets the default settings for all SplitType instances.\n   *\n   * Setting `SplitType.defaults` to an object will merge that object with the\n   * existing defaults.\n   *\n   * @param {Object} settings an object containing the settings to override\n   * @deprecated\n   * @static\n   * @example\n   * SplitType.defaults = { \"position\": \"absolute\" }\n   */\n\n\n  static set defaults(options) {\n    _defaults = extend(_defaults, parseSettings(options));\n  }\n  /**\n   * Sets the default settings for all SplitType instances.\n   * The provided object will be merged with the existing defaults objects.\n   *\n   * @param {Object} settings an object containing the settings to override\n   * @returns {Object} the new default settings\n   * @public\n   * @static\n   * @example\n   * SplitType.setDefaults({ \"position\": \"absolute\" })\n   */\n\n\n  static setDefaults(options) {\n    _defaults = extend(_defaults, parseSettings(options));\n    return defaults;\n  }\n  /**\n   * Revert target elements to their original html content\n   * Has no effect on that\n   *\n   * @param {any} elements The target elements to revert. One of:\n   *  - {string} A css selector\n   *  - {HTMLElement} A single element\n   * -  {NodeList} A NodeList or collection\n   *  - {HTMLElement[]} An array of Elements\n   * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\n   * @static\n   */\n\n\n  static revert(elements) {\n    getTargetElements(elements).forEach(element => {\n      const {\n        isSplit,\n        html,\n        cssWidth,\n        cssHeight\n      } = get(element);\n\n      if (isSplit) {\n        element.innerHTML = html;\n        element.style.width = cssWidth || '';\n        element.style.height = cssHeight || '';\n        remove(element);\n      }\n    });\n  }\n  /**\n   * Creates a new SplitType instance\n   * This static method provides a way to create a `SplitType` instance without\n   * using the `new` keyword.\n   *\n   * @param {any} target The target elements to split. One of:\n   *  - {string} A css selector\n   *  - {HTMLElement} A single element\n   * -  {NodeList} A NodeList or collection\n   *  - {HTMLElement[]} An array of Elements\n   * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\n   * @param {Object} [options] Settings for the SplitType instance\n   * @return {SplitType} the SplitType instance\n   * @static\n   */\n\n\n  static create(target, options) {\n    return new SplitType(target, options);\n  }\n  /**\n   * Creates a new `SplitType` instance\n   *\n   * @param {any} elements The target elements to split. One of:\n   *  - {string} A css selector\n   *  - {HTMLElement} A single element\n   * -  {NodeList} A NodeList or collection\n   *  - {HTMLElement[]} An array of Elements\n   * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\n   * @param {Object} [options] Settings for the SplitType instance\n   */\n\n\n  constructor(elements, options) {\n    this.isSplit = false;\n    this.settings = extend(_defaults, parseSettings(options));\n    this.elements = getTargetElements(elements); // Start the split process\n\n    this.split();\n  }\n  /**\n   * Splits the text in all target elements. This method is called\n   * automatically when a new SplitType instance is created. It can also be\n   * called manually to re-split text with new options.\n   * @param {Object} options\n   * @public\n   */\n\n\n  split(options) {\n    // Revert target elements (if they are already split)\n    // Note: revert was already called once in the constructor. However, we\n    // need to call it again here so text is reverted when the user manually\n    // calls the `split` method to re-split text.\n    this.revert(); // Store the original html content of each target element\n\n    this.elements.forEach(element => {\n      set(element, 'html', element.innerHTML);\n    }); // Create arrays to hold the split lines, words, and characters\n\n    this.lines = [];\n    this.words = [];\n    this.chars = []; // cache vertical scroll position before splitting\n\n    const scrollPos = [window.pageXOffset, window.pageYOffset]; // If new options were passed into the `split()` method, update settings\n\n    if (options !== undefined) {\n      this.settings = extend(this.settings, parseSettings(options));\n    }\n\n    const types = parseTypes(this.settings.types); // If the `types` option is set to an empty array, text will not be split.\n    // @example new SplitType('#target', { types: [] })\n\n    if (types.none) {\n      return;\n    } // Split text in each target element\n\n\n    this.elements.forEach(element => {\n      // Add the split text nodes from this element to the arrays of all split\n      // text nodes for this instance.\n      set(element, 'isRoot', true);\n      const {\n        words,\n        chars\n      } = split(element, this.settings);\n      this.words = [...this.words, ...words];\n      this.chars = [...this.chars, ...chars];\n    });\n    this.elements.forEach(element => {\n      if (types.lines || this.settings.absolute) {\n        const lines = repositionAfterSplit(element, this.settings, scrollPos);\n        this.lines = [...this.lines, ...lines];\n      }\n    }); // Set isSplit to true for the SplitType instance\n\n    this.isSplit = true; // Set scroll position to cached value.\n\n    window.scrollTo(scrollPos[0], scrollPos[1]); // Clean up stored data\n\n    cleanup();\n  }\n  /**\n   * Reverts target element(s) back to their original html content\n   * Deletes all stored data associated with the target elements\n   * Resets the properties on the splitType instance\n   *\n   * @public\n   */\n\n\n  revert() {\n    if (this.isSplit) {\n      // Reset instance properties if necessary\n      this.lines = null;\n      this.words = null;\n      this.chars = null;\n      this.isSplit = false;\n    }\n\n    SplitType.revert(this.elements);\n  }\n\n}\n\nexport { SplitType as default };\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _classCallCheck;\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _createClass;\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _objectSpread;\nvar _defineProperty = _interopRequireDefault(require(\"./_define_property\"));\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            (0, _defineProperty).default(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _defineProperty;\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _slicedToArray;\nvar _arrayWithHoles = _interopRequireDefault(require(\"./_array_with_holes\"));\nvar _iterableToArray = _interopRequireDefault(require(\"./_iterable_to_array\"));\nvar _nonIterableRest = _interopRequireDefault(require(\"./_non_iterable_rest\"));\nvar _unsupportedIterableToArray = _interopRequireDefault(require(\"./_unsupported_iterable_to_array\"));\nfunction _slicedToArray(arr, i) {\n    return (0, _arrayWithHoles).default(arr) || (0, _iterableToArray).default(arr, i) || (0, _unsupportedIterableToArray).default(arr, i) || (0, _nonIterableRest).default();\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _arrayWithHoles;\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _iterableToArray;\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _nonIterableRest;\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _unsupportedIterableToArray;\nvar _arrayLikeToArray = _interopRequireDefault(require(\"./_array_like_to_array\"));\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return (0, _arrayLikeToArray).default(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return (0, _arrayLikeToArray).default(o, minLen);\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _arrayLikeToArray;\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _toConsumableArray;\nvar _arrayWithoutHoles = _interopRequireDefault(require(\"./_array_without_holes\"));\nvar _iterableToArray = _interopRequireDefault(require(\"./_iterable_to_array\"));\nvar _nonIterableSpread = _interopRequireDefault(require(\"./_non_iterable_spread\"));\nvar _unsupportedIterableToArray = _interopRequireDefault(require(\"./_unsupported_iterable_to_array\"));\nfunction _toConsumableArray(arr) {\n    return (0, _arrayWithoutHoles).default(arr) || (0, _iterableToArray).default(arr) || (0, _unsupportedIterableToArray).default(arr) || (0, _nonIterableSpread).default();\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _arrayWithoutHoles;\nvar _arrayLikeToArray = _interopRequireDefault(require(\"./_array_like_to_array\"));\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return (0, _arrayLikeToArray).default(arr);\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _nonIterableSpread;\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n"],"names":["$8NJRj","parcelRequire","gsap","default","console","error","matchesMobile","ref","window","matchMedia","matches","types","tagName","textRevealTimeline","timeline","imagesTimeline","to","scrollTrigger","trigger","start","scrub","end","y","ease","opacity","pin","containerAnimation","from","stagger","amount","duration","once","$8MBJY","$668678f4fe7971b1$var$extend","target","object","Object","getOwnPropertyNames","reduce","extended","key","currentValue","getOwnPropertyDescriptor","newValue","defineProperty","$668678f4fe7971b1$var$isString","value","$668678f4fe7971b1$var$isArray","Array","isArray","$668678f4fe7971b1$var$parseSettings","settings","arguments","length","undefined","split","String","map","type","trim","filter","test","absolute","position","$668678f4fe7971b1$var$parseTypes","none","lines","words","chars","$668678f4fe7971b1$var$isObject","$668678f4fe7971b1$var$isNode","input","nodeType","$668678f4fe7971b1$var$toArray","$668678f4fe7971b1$var$isLength","$668678f4fe7971b1$var$isArrayLike","prototype","slice","call","$668678f4fe7971b1$var$getTargetElements","elements","document","getElementById","querySelectorAll","result","element","$parcel$interopDefault","$8nrFW","concat","append","_len","nodes","_key","i","node","this","appendChild","createTextNode","replaceChildren","lastChild","removeChild","apply","replaceWith","parent","parentNode","ownerDocument","insertBefore","previousSibling","replaceChild","Element","DocumentFragment","$668678f4fe7971b1$var$entries","entries","$668678f4fe7971b1$var$cache","keys","values","$668678f4fe7971b1$var$uid","$668678f4fe7971b1$var$set","owner","warn","id","data","getPrototypeOf","$dDDEV","$668678f4fe7971b1$var$get","$668678f4fe7971b1$var$remove","$668678f4fe7971b1$var$rsAstralRange","$668678f4fe7971b1$var$rsComboMarksRange","$668678f4fe7971b1$var$rsComboSymbolsRange","$668678f4fe7971b1$var$rsVarRange","$668678f4fe7971b1$var$rsAstral","$668678f4fe7971b1$var$rsCombo","$668678f4fe7971b1$var$rsFitz","$668678f4fe7971b1$var$rsModifier","$668678f4fe7971b1$var$rsNonAstral","$668678f4fe7971b1$var$rsRegional","$668678f4fe7971b1$var$rsSurrPair","$668678f4fe7971b1$var$rsZWJ","$668678f4fe7971b1$var$reOptMod","$668678f4fe7971b1$var$rsOptVar","$668678f4fe7971b1$var$rsSeq","join","$668678f4fe7971b1$var$rsSymbol","$668678f4fe7971b1$var$reUnicode","RegExp","$668678f4fe7971b1$var$reHasUnicode","$668678f4fe7971b1$var$hasUnicode","string","$668678f4fe7971b1$var$stringToArray","match","$668678f4fe7971b1$var$unicodeToArray","$668678f4fe7971b1$var$asciiToArray","$668678f4fe7971b1$var$toString","$668678f4fe7971b1$var$createElement","name","attributes","createElement","forEach","attribute","_element","rawValue","setAttribute","$668678f4fe7971b1$var$defaults","splitClass","lineClass","wordClass","charClass","$668678f4fe7971b1$var$splitWordsAndChars","textNode","TAG_NAME","VALUE","nodeValue","splitText","createDocumentFragment","separator","replace","$668678f4fe7971b1$var$toWords","WORD","idx","arr","wordElement","characterElementsForCurrentWord","$668678f4fe7971b1$var$toChars","CHAR","characterElement","class","style","children","isWord","isWordStart","isWordEnd","$668678f4fe7971b1$var$split","wordsAndChars","childNodes","isRoot","display","nextSibling","prevSibling","text","textContent","textAfter","textBefore","child","$668678f4fe7971b1$var$unSplitWords","$668678f4fe7971b1$var$repositionAfterSplit","scrollPos","elementHeight","elementWidth","contentBox","getElementsByTagName","wordsInEachLine","wordsInCurrentLine","lineOffsetY","parentElement","nextElementSibling","cs","getComputedStyle","align","textAlign","lineThreshold","parseFloat","fontSize","left","offsetLeft","top","offsetTop","width","offsetWidth","offsetHeight","cssWidth","cssHeight","height","isWordLike","offsetParent","_scrollPos","$1t1Wn","scrollX","scrollY","parentX","parentY","body","parentRect","getBoundingClientRect","x","$668678f4fe7971b1$var$getPosition","nodeName","push","wordsInThisLine","lineElement","lineDimensions","wordOrElement","next","Math","max","min","isLine","parentData","isChildOfLineNode","$668678f4fe7971b1$var$_defaults","$668678f4fe7971b1$export$2e2bcd8739ae039","SplitType","options","isSplit","revert","innerHTML","pageXOffset","pageYOffset","_this","scrollTo","param","_param","html","module","exports","instance","Constructor","TypeError","$74e7f8130373505f$var$_defineProperties","props","descriptor","enumerable","configurable","writable","protoProps","staticProps","source","ownKeys","getOwnPropertySymbols","sym","$9eddae5a012cde57$var$_defineProperty","obj","__esModule","$111a013c31e2261e$var$_arrayWithHoles","$111a013c31e2261e$var$_iterableToArray","$111a013c31e2261e$var$_unsupportedIterableToArray","$111a013c31e2261e$var$_nonIterableRest","$111a013c31e2261e$var$_interopRequireDefault","iter","Symbol","iterator","o","minLen","$7a2c4c4c44c69707$var$_arrayLikeToArray","n","toString","constructor","len","arr2","$6195f07b5409ba15$var$_arrayWithoutHoles","$6195f07b5409ba15$var$_iterableToArray","$6195f07b5409ba15$var$_unsupportedIterableToArray","$6195f07b5409ba15$var$_nonIterableSpread","$6195f07b5409ba15$var$_interopRequireDefault","$f215c72f040a88cf$var$_arrayLikeToArray"],"version":3,"file":"reveal-text-on-scroll.99ed5b60.js.map"}